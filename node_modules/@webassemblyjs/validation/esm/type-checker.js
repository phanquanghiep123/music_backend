function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { traverse, isInstruction } from "@webassemblyjs/ast";
import { moduleContextFromModuleAST } from "@webassemblyjs/helper-module-context";
import getType from "./type-checker/get-type.js";
import { ANY, POLYMORPHIC } from "./type-checker/types.js";
var errors = [];
var stopFuncCheck = false;

function checkTypes(a, b) {
  if (a === ANY && b) {
    return;
  }

  if (b === ANY && a) {
    return;
  } // the type u32 is equal to i32


  if (a === "u32") a = "i32";
  if (b === "u32") b = "i32"; // the type u64 is equal to i64

  if (a === "u64") a = "i64";
  if (b === "u64") b = "i64";

  if (a !== b) {
    errors.push("Expected type ".concat(a, " but got ").concat(b || "none", "."));
    stopFuncCheck = true;
  }
}

export default function validate(ast) {
  if (!ast.body || !ast.body[0] || !ast.body[0].fields) {
    return [];
  } // Module context


  var moduleContext = moduleContextFromModuleAST(ast.body[0]);
  errors = []; // Simulate stack types throughout all function bodies

  traverse(ast, {
    Func: function Func(_ref) {
      var node = _ref.node;
      stopFuncCheck = false;
      var expectedResult = node.signature.results;
      moduleContext.newContext(node.name.value, expectedResult); // Parameters are local variables

      node.signature.params.forEach(function (p) {
        return moduleContext.addLocal(p.valtype);
      });
      var resultingStack = node.body.reduce(applyInstruction.bind(null, moduleContext), []);

      if (stopFuncCheck) {
        return errors;
      } // Compare the two


      checkStacks(expectedResult, resultingStack);
    }
  });
  return errors;
}

function isEmptyStack(stack) {
  // Polymorphic types are allowed in empty stack
  return stack.filter(function (t) {
    return t !== POLYMORPHIC;
  }).length === 0;
}

function checkStacks(expectedStack, actualStack) {
  if (actualStack !== false) {
    var j = actualStack.length - 1;

    for (var i = 0; i < expectedStack.length; ++i) {
      var expected = expectedStack[i];
      var actual = actualStack[j];

      if (actual === POLYMORPHIC || stopFuncCheck) {
        return;
      }

      checkTypes(expected, actual);
      --j;
    } // There are still types left on the resulting stack


    if (!isEmptyStack(actualStack.slice(0, j + 1))) {
      errors.push("Stack contains additional type ".concat(actualStack.slice(0, j + 1), "."));
    }
  }
}

function applyInstruction(moduleContext, stack, instruction) {
  // Return was called or a type error has occured, skip everything
  if (stack === false || stack.return) {
    return stack;
  } // Workaround for node.args which sometimes does not contain instructions (i32.const, call)


  if (isInstruction(instruction) === false) {
    return stack;
  } // Recursively evaluate all nested instructions


  if (instruction.args) {
    stack = instruction.args.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  if (instruction.instrArgs) {
    stack = instruction.instrArgs.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  if (instruction.intrs) {
    stack = instruction.intrs.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  var type = getType(moduleContext, stack, instruction);

  if (type.error) {
    errors.push(type.error);
    return false;
  } // Structured control flow
  // Update context
  // Run on empty stack


  if (instruction.type === "BlockInstruction" || instruction.type === "LoopInstruction") {
    moduleContext.addLabel(type.result);
    var newStack = instruction.instr.reduce(applyInstruction.bind(null, moduleContext), []);

    if (!stopFuncCheck) {
      checkStacks(type.result, newStack);
    }

    if (newStack === false) {
      stack = false;
    } else {
      stack = _toConsumableArray(stack).concat(_toConsumableArray(newStack));
    }

    moduleContext.popLabel();
  } else if (instruction.type === "IfInstruction") {
    moduleContext.addLabel(type.result); // Condition can be nested as well

    if (instruction.test) {
      stack = instruction.test.reduce(applyInstruction.bind(null, moduleContext), stack);
    }

    var actual;

    for (var _i = 0; _i < type.args.length; ++_i) {
      var argType = type.args[_i];

      if (stack[stack.length - 1] === POLYMORPHIC || stopFuncCheck) {
        return false;
      }

      actual = stack.pop();
      checkTypes(argType, actual);
    }

    var stackConsequent = instruction.consequent.reduce(applyInstruction.bind(null, moduleContext), []);
    var stackAlternate = instruction.alternate.reduce(applyInstruction.bind(null, moduleContext), []);
    var i = 0;
    var j = 0;
    var compareLengths = true;

    while (i < stackConsequent.length && j < stackAlternate.length) {
      if (stackConsequent[i] === POLYMORPHIC || stackAlternate[j] === POLYMORPHIC) {
        compareLengths = false;
        break;
      }

      checkTypes(stackConsequent[i], stackAlternate[j]);
      ++i;
      ++j;
    }

    while (compareLengths && i < stackConsequent.length) {
      if (stackConsequent[i] === POLYMORPHIC) {
        compareLengths = false;
      }

      ++i;
    }

    while (compareLengths && j < stackConsequent.length) {
      if (stackConsequent[j] === POLYMORPHIC) {
        compareLengths = false;
      }

      ++j;
    }

    if (compareLengths && stackConsequent.length !== stackAlternate.length) {
      errors.push("Type mismatch in if, got ".concat(stackConsequent, " and ").concat(stackAlternate));
    }

    checkStacks(type.result, stackConsequent);
    moduleContext.popLabel(); // Add to existing stack

    stack = _toConsumableArray(stack).concat(_toConsumableArray(stackConsequent));
  } else {
    if (stack === false) {
      return false;
    }

    var _actual;

    for (var _i2 = 0; _i2 < type.args.length; ++_i2) {
      var _argType = type.args[_i2];

      if (stack[stack.length - 1] === POLYMORPHIC || stopFuncCheck) {
        return false;
      }

      _actual = stack.pop();
      checkTypes(_argType, _actual);
    }

    stack = _toConsumableArray(stack).concat(_toConsumableArray(type.result));
  }

  return stack;
}